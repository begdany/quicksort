// Функция быстрой сортировки, принимает изменяемый массив
fn quicksort<T: Ord + Clone>(arr: &mut [T]) {
    // Если длина массива меньше или равна 1, он уже отсортирован
    if arr.len() <= 1 {
        return;
    }

    // Разделяем массив и получаем индекс опорного элемента
    let pivot_index = partition(arr);
    
    // Рекурсивно сортируем левую часть массива
    quicksort(&mut arr[..pivot_index]);
    // Рекурсивно сортируем правую часть массива
    quicksort(&mut arr[pivot_index + 1..]);
}

// Функция для разделения массива на части
fn partition<T: Ord + Clone>(arr: &mut [T]) -> usize {
    // Выбираем опорный элемент (средний элемент)
    let pivot_index = arr.len() / 2;
    let pivot_value = arr[pivot_index].clone();
    
    // Перемещаем опорный элемент в конец массива
    arr.swap(pivot_index, arr.len() - 1);

    // Индекс, указывающий на место для перемещения меньших элементов
    let mut store_index = 0;
    
    // Проходим по всем элементам, кроме последнего (опорного)
    for i in 0..arr.len() - 1 {
        // Если текущий элемент меньше опорного
        if &arr[i] < &pivot_value {
            // Меняем его местами с элементом на позиции store_index
            arr.swap(i, store_index);
            // Увеличиваем индекс для хранения
            store_index += 1;
        }
    }

    // Перемещаем опорный элемент на его окончательное место
    arr.swap(store_index, arr.len() - 1);
    
    // Возвращаем индекс опорного элемента
    store_index
}

// Главная функция, точка входа в программу
fn main() {
    // Инициализируем массив для сортировки
    let mut arr = [3300, 25, 90, 2, 1, 1, 127, 0, 0];
    
    // Вызываем функцию быстрой сортировки
    quicksort(&mut arr);
    
    // Выводим отсортированный массив
    println!("{:?}", arr);
}
